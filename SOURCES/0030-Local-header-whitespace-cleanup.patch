From b6db7342f15a86f734445e83198dde024544e492 Mon Sep 17 00:00:00 2001
From: Peter Jones <pjones@redhat.com>
Date: Mon, 17 Jun 2019 14:25:21 -0400
Subject: [PATCH 30/63] Local header whitespace cleanup.

Signed-off-by: Peter Jones <pjones@redhat.com>
---
 src/crc32.h         |   2 +
 src/disk.h          |   4 +-
 src/dp.h            |   2 +
 src/efiboot.h       |   3 +-
 src/efivar.h        |   3 +-
 src/efivar_endian.h |   2 +
 src/fix_coverity.h  |  28 ++-
 src/generics.h      |   2 +
 src/gpt.h           |  97 ++++----
 src/guid.h          |  20 +-
 src/hexdump.h       |   2 +
 src/lib.h           |   2 +
 src/linux.h         | 370 +++++++++++++++---------------
 src/path-helpers.h  |  37 +--
 src/ucs2.h          |   2 +
 src/util.h          | 532 ++++++++++++++++++++++----------------------
 16 files changed, 572 insertions(+), 536 deletions(-)

diff --git a/src/crc32.h b/src/crc32.h
index 405d23c86ec..b5b975a5768 100644
--- a/src/crc32.h
+++ b/src/crc32.h
@@ -30,3 +30,5 @@
 extern uint32_t crc32 (const void *buf, unsigned long len, uint32_t seed);
 
 #endif /* _CRC32_H */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/disk.h b/src/disk.h
index f0fa7f9f42d..8ba0f4602f4 100644
--- a/src/disk.h
+++ b/src/disk.h
@@ -24,6 +24,8 @@
 extern bool HIDDEN is_partitioned(int fd);
 
 extern HIDDEN ssize_t make_hd_dn(uint8_t *buf, ssize_t size, int fd,
-                                 int32_t partition, uint32_t options);
+				 int32_t partition, uint32_t options);
 
 #endif /* _EFIBOOT_DISK_H */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/dp.h b/src/dp.h
index 1f921d524aa..33a29db0d5d 100644
--- a/src/dp.h
+++ b/src/dp.h
@@ -187,3 +187,5 @@ extern ssize_t _format_bios_boot_dn(char *buf, size_t size, const_efidp dp);
 	format_helper_2(_format_bios_boot_dn, buf, size, off, dp)
 
 #endif /* _EFIVAR_INTERNAL_DP_H */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/efiboot.h b/src/efiboot.h
index f60f2cf5c2a..23275ed82bf 100644
--- a/src/efiboot.h
+++ b/src/efiboot.h
@@ -24,4 +24,5 @@
 #include <efivar/efiboot.h>
 
 #endif /* !PRIVATE_EFIBOOT_H_ */
-// vim:fenc=utf-8:tw=75:et
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/efivar.h b/src/efivar.h
index ce6beb6850b..3d4b429631e 100644
--- a/src/efivar.h
+++ b/src/efivar.h
@@ -36,4 +36,5 @@
 #include "path-helpers.h"
 
 #endif /* !PRIVATE_EFIVAR_H_ */
-// vim:fenc=utf-8:tw=75:et
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/efivar_endian.h b/src/efivar_endian.h
index b8e6a314838..bed4603ad71 100644
--- a/src/efivar_endian.h
+++ b/src/efivar_endian.h
@@ -51,3 +51,5 @@
 #endif
 
 #endif /* _EFIVAR_ENDIAN_H */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/fix_coverity.h b/src/fix_coverity.h
index 95a5c9282c9..acb4cc65eff 100644
--- a/src/fix_coverity.h
+++ b/src/fix_coverity.h
@@ -22,8 +22,8 @@
  *
  * In glibc's headers, bits/floatn.h has:
  *
- * #if (defined __x86_64__                                              \
- *   ? __GNUC_PREREQ (4, 3)                                             \
+ * #if (defined __x86_64__						\
+ *   ? __GNUC_PREREQ (4, 3)						\
  *   : (defined __GNU__ ? __GNUC_PREREQ (4, 5) : __GNUC_PREREQ (4, 4)))
  * # define __HAVE_FLOAT128 1
  * #else
@@ -35,24 +35,21 @@
  * #if __HAVE_FLOAT128 && __GLIBC_USE (IEC_60559_TYPES_EXT)
  * slash* Likewise for the '_Float128' format  *slash
  * extern _Float128 strtof128 (const char *__restrict __nptr,
- *                       char **__restrict __endptr)
- *      __THROW __nonnull ((1));
+ *			       char **__restrict __endptr)
+ *	__THROW __nonnull ((1));
  * #endif
  *
  * Which then causes cov-emit to lose its shit:
  *
- * "/usr/include/stdlib.h", line 133: error #20: identifier "_Float128" is
- *           undefined
+ * "/usr/include/stdlib.h", line 133: error #20: identifier "_Float128" is undefined
  *   extern _Float128 strtof128 (const char *__restrict __nptr,
- *          ^
- * "/usr/include/stdlib.h", line 190: error #20: identifier "_Float128" is
- *           undefined
- *                         _Float128 __f)
- *                         ^
- * "/usr/include/stdlib.h", line 236: error #20: identifier "_Float128" is
- *           undefined
+ *	    ^
+ * "/usr/include/stdlib.h", line 190: error #20: identifier "_Float128" is undefined
+ *			 _Float128 __f)
+ *			 ^
+ * "/usr/include/stdlib.h", line 236: error #20: identifier "_Float128" is undefined
  *   extern _Float128 strtof128_l (const char *__restrict __nptr,
- *          ^
+ *	    ^
  *
  * And then you'll notice something like this later on:
  * [WARNING] Emitted 0 C/C++ compilation units (0%) successfully
@@ -91,4 +88,5 @@ typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
 #endif
 
 #endif /* !FIX_COVERITY_H */
-// vim:fenc=utf-8:tw=75
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/generics.h b/src/generics.h
index 66be4bd76ab..8ade54ee96b 100644
--- a/src/generics.h
+++ b/src/generics.h
@@ -184,3 +184,5 @@ generic_append_variable(efi_guid_t guid, const char *name,
 
 #endif /* LIBEFIVAR_GENERIC_NEXT_VARIABLE_NAME_H */
 #endif /* EFIVAR_BUILD_ENVIRONMENT */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/gpt.h b/src/gpt.h
index 0d7d5e8a649..66fbc21106c 100644
--- a/src/gpt.h
+++ b/src/gpt.h
@@ -38,27 +38,27 @@
 #define GPT_HEADER_REVISION_V0_99 0x00009900
 #define GPT_PRIMARY_PARTITION_TABLE_LBA 1
 
-#define PARTITION_SYSTEM_GUID                           \
-        EFI_GUID(0xC12A7328, 0xF81F, 0x11d2, 0xBA4B,    \
-                 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B)
-#define LEGACY_MBR_PARTITION_GUID                       \
-        EFI_GUID(0x024DEE41, 0x33E7, 0x11d3, 0x9D69,    \
-                 0x00, 0x08, 0xC7, 0x81, 0xF3, 0x9F)
-#define PARTITION_MSFT_RESERVED_GUID                    \
-        EFI_GUID(0xE3C9E316, 0x0B5C, 0x4DB8, 0x817D,    \
-                 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE)
-#define PARTITION_BASIC_DATA_GUID                       \
-        EFI_GUID(0xEBD0A0A2, 0xB9E5, 0x4433, 0x87C0,    \
-                 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7)
-#define PARTITION_LINUX_RAID_GUID                       \
-        EFI_GUID(0xa19d880f, 0x05fc, 0x4d3b, 0xA006,    \
-                 0x74, 0x3f, 0x0f, 0x84, 0x91, 0x1e)
-#define PARTITION_LINUX_SWAP_GUID                       \
-        EFI_GUID(0x0657fd6d, 0xa4ab, 0x43c4, 0x84E5,    \
-                 0x09, 0x33, 0xc8, 0x4b, 0x4f, 0x4f)
-#define PARTITION_LINUX_LVM_GUID                        \
-        EFI_GUID(0xe6d6d379, 0xf507, 0x44c2, 0xa23c,    \
-                 0x23, 0x8f, 0x2a, 0x3d, 0xf9, 0x28)
+#define PARTITION_SYSTEM_GUID				\
+	EFI_GUID(0xC12A7328, 0xF81F, 0x11d2, 0xBA4B,	\
+		 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B)
+#define LEGACY_MBR_PARTITION_GUID			\
+	EFI_GUID(0x024DEE41, 0x33E7, 0x11d3, 0x9D69,	\
+		 0x00, 0x08, 0xC7, 0x81, 0xF3, 0x9F)
+#define PARTITION_MSFT_RESERVED_GUID			\
+	EFI_GUID(0xE3C9E316, 0x0B5C, 0x4DB8, 0x817D,	\
+		 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE)
+#define PARTITION_BASIC_DATA_GUID			\
+	EFI_GUID(0xEBD0A0A2, 0xB9E5, 0x4433, 0x87C0,	\
+		 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7)
+#define PARTITION_LINUX_RAID_GUID			\
+	EFI_GUID(0xa19d880f, 0x05fc, 0x4d3b, 0xA006,	\
+		 0x74, 0x3f, 0x0f, 0x84, 0x91, 0x1e)
+#define PARTITION_LINUX_SWAP_GUID			\
+	EFI_GUID(0x0657fd6d, 0xa4ab, 0x43c4, 0x84E5,	\
+		 0x09, 0x33, 0xc8, 0x4b, 0x4f, 0x4f)
+#define PARTITION_LINUX_LVM_GUID			\
+	EFI_GUID(0xe6d6d379, 0xf507, 0x44c2, 0xa23c,	\
+		 0x23, 0x8f, 0x2a, 0x3d, 0xf9, 0x28)
 
 typedef struct _gpt_header {
 	uint64_t magic;
@@ -81,7 +81,7 @@ typedef struct _gpt_header {
 typedef struct _gpt_entry_attributes {
 	uint64_t required_to_function:1;
 	uint64_t reserved:47;
-        uint64_t type_guid_specific:16;
+	uint64_t type_guid_specific:16;
 } PACKED gpt_entry_attributes;
 
 typedef struct _gpt_entry {
@@ -103,25 +103,36 @@ typedef struct _gpt_entry {
  * Number of actual partition entries should be calculated as:
  */
 #define GPT_DEFAULT_RESERVED_PARTITION_ENTRIES \
-        (GPT_DEFAULT_RESERVED_PARTITION_ENTRY_ARRAY_SIZE / \
-         sizeof(gpt_entry))
+	(GPT_DEFAULT_RESERVED_PARTITION_ENTRY_ARRAY_SIZE / \
+	 sizeof(gpt_entry))
 
 typedef struct _partition_record {
-	uint8_t boot_indicator; /* Not used by EFI firmware. Set to 0x80 to indicate that this
-                                   is the bootable legacy partition. */
-	uint8_t start_head;     /* Start of partition in CHS address, not used by EFI firmware. */
-	uint8_t start_sector;   /* Start of partition in CHS address, not used by EFI firmware. */
-	uint8_t start_track;    /* Start of partition in CHS address, not used by EFI firmware. */
-	uint8_t os_type;        /* OS type. A value of 0xEF defines an EFI system partition.
-                                   Other values are reserved for legacy operating systems, and
-                                   allocated independently of the EFI specification. */
-	uint8_t end_head;       /* End of partition in CHS address, not used by EFI firmware. */
-	uint8_t end_sector;     /* End of partition in CHS address, not used by EFI firmware. */
-	uint8_t end_track;      /* End of partition in CHS address, not used by EFI firmware. */
-	uint32_t starting_lba;  /* Starting LBA address of the partition on the disk. Used by
-                                   EFI firmware to define the start of the partition. */
-	uint32_t size_in_lba;   /* Size of partition in LBA. Used by EFI firmware to determine
-                                   the size of the partition. */
+	uint8_t boot_indicator; /* Not used by EFI firmware. Set to 0x80 to
+				   indicate that this is the bootable
+				   legacy partition. */
+	uint8_t start_head;     /* Start of partition in CHS address, not
+				   used by EFI firmware. */
+	uint8_t start_sector;   /* Start of partition in CHS address, not
+				   used by EFI firmware. */
+	uint8_t start_track;    /* Start of partition in CHS address, not
+				   used by EFI firmware. */
+	uint8_t os_type;	/* OS type. A value of 0xEF defines an EFI
+				   system partition.
+				   Other values are reserved for legacy
+				   operating systems, and allocated
+				   independently of the EFI specification. */
+	uint8_t end_head;       /* End of partition in CHS address, not
+				   used by EFI firmware. */
+	uint8_t end_sector;     /* End of partition in CHS address, not
+				   used by EFI firmware. */
+	uint8_t end_track;      /* End of partition in CHS address, not
+				   used by EFI firmware. */
+	uint32_t starting_lba;  /* Starting LBA address of the partition on
+				   the disk. Used by EFI firmware to define
+				   the start of the partition. */
+	uint32_t size_in_lba;	/* Size of partition in LBA. Used by EFI
+				   firmware to determine the size of the
+				   partition. */
 } PACKED partition_record;
 
 /*
@@ -141,8 +152,10 @@ typedef struct _legacy_mbr {
 /* Functions */
 extern int NONNULL(3, 4, 5, 6, 7) HIDDEN
 gpt_disk_get_partition_info (int fd, uint32_t num, uint64_t *start,
-                             uint64_t *size, uint8_t *signature,
-                             uint8_t *mbr_type, uint8_t *signature_type,
-                             int ignore_pmbr_error, int logical_sector_size);
+			     uint64_t *size, uint8_t *signature,
+			     uint8_t *mbr_type, uint8_t *signature_type,
+			     int ignore_pmbr_error, int logical_sector_size);
 
 #endif /* _EFIBOOT_GPT_H */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/guid.h b/src/guid.h
index d4a06f957a5..3229621a3f1 100644
--- a/src/guid.h
+++ b/src/guid.h
@@ -110,7 +110,7 @@ text_to_guid(const char *text, efi_guid_t *guid)
 	guid->a = cpu_to_le32(guid->a);
 
 	/* 84be9c3e-8a32-42c0-891c-4cd3b072becc
-	 *          ^ */
+	 *	  ^ */
 	strncpy(fourbytes, text+9, 4);
 	if (check_segment_sanity(fourbytes, 4) < 0)
 		return -1;
@@ -118,7 +118,7 @@ text_to_guid(const char *text, efi_guid_t *guid)
 	guid->b = cpu_to_le16(guid->b);
 
 	/* 84be9c3e-8a32-42c0-891c-4cd3b072becc
-	 *               ^ */
+	 *	       ^ */
 	strncpy(fourbytes, text+14, 4);
 	if (check_segment_sanity(fourbytes, 4) < 0)
 		return -1;
@@ -126,7 +126,7 @@ text_to_guid(const char *text, efi_guid_t *guid)
 	guid->c = cpu_to_le16(guid->c);
 
 	/* 84be9c3e-8a32-42c0-891c-4cd3b072becc
-	 *                    ^ */
+	 *		    ^ */
 	strncpy(fourbytes, text+19, 4);
 	if (check_segment_sanity(fourbytes, 4) < 0)
 		return -1;
@@ -134,42 +134,42 @@ text_to_guid(const char *text, efi_guid_t *guid)
 	guid->d = cpu_to_be16(guid->d);
 
 	/* 84be9c3e-8a32-42c0-891c-4cd3b072becc
-	 *                         ^ */
+	 *			 ^ */
 	strncpy(twobytes, text+24, 2);
 	if (check_segment_sanity(twobytes, 2) < 0)
 		return -1;
 	guid->e[0] = (uint8_t)strtoul(twobytes, NULL, 16);
 
 	/* 84be9c3e-8a32-42c0-891c-4cd3b072becc
-	 *                           ^ */
+	 *			   ^ */
 	strncpy(twobytes, text+26, 2);
 	if (check_segment_sanity(twobytes, 2) < 0)
 		return -1;
 	guid->e[1] = (uint8_t)strtoul(twobytes, NULL, 16);
 
 	/* 84be9c3e-8a32-42c0-891c-4cd3b072becc
-	 *                             ^ */
+	 *			     ^ */
 	strncpy(twobytes, text+28, 2);
 	if (check_segment_sanity(twobytes, 2) < 0)
 		return -1;
 	guid->e[2] = (uint8_t)strtoul(twobytes, NULL, 16);
 
 	/* 84be9c3e-8a32-42c0-891c-4cd3b072becc
-	 *                               ^ */
+	 *			       ^ */
 	strncpy(twobytes, text+30, 2);
 	if (check_segment_sanity(twobytes, 2) < 0)
 		return -1;
 	guid->e[3] = (uint8_t)strtoul(twobytes, NULL, 16);
 
 	/* 84be9c3e-8a32-42c0-891c-4cd3b072becc
-	 *                                 ^ */
+	 *				 ^ */
 	strncpy(twobytes, text+32, 2);
 	if (check_segment_sanity(twobytes, 2) < 0)
 		return -1;
 	guid->e[4] = (uint8_t)strtoul(twobytes, NULL, 16);
 
 	/* 84be9c3e-8a32-42c0-891c-4cd3b072becc
-	 *                                   ^ */
+	 *				   ^ */
 	strncpy(twobytes, text+34, 2);
 	if (check_segment_sanity(twobytes, 2) < 0)
 		return -1;
@@ -185,3 +185,5 @@ struct guidname {
 };
 
 #endif /* LIBEFIVAR_GUID */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/hexdump.h b/src/hexdump.h
index f8c32faa9e1..d88aa507b8d 100644
--- a/src/hexdump.h
+++ b/src/hexdump.h
@@ -114,3 +114,5 @@ hexdump(uint8_t *data, unsigned long size)
 }
 
 #endif /* STATIC_HEXDUMP_H */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/lib.h b/src/lib.h
index 5024128c42c..3cc29a01fb4 100644
--- a/src/lib.h
+++ b/src/lib.h
@@ -51,3 +51,5 @@ extern struct efi_var_operations vars_ops;
 extern struct efi_var_operations efivarfs_ops;
 
 #endif /* LIBEFIVAR_LIB_H */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/linux.h b/src/linux.h
index 43a9b7899f5..5ae64ffaacf 100644
--- a/src/linux.h
+++ b/src/linux.h
@@ -22,75 +22,75 @@
 #define _EFIBOOT_LINUX_H
 
 struct acpi_root_info {
-        uint32_t acpi_hid;
-        uint64_t acpi_uid;
-        uint32_t acpi_cid;
-        char *acpi_hid_str;
-        char *acpi_uid_str;
-        char *acpi_cid_str;
+	uint32_t acpi_hid;
+	uint64_t acpi_uid;
+	uint32_t acpi_cid;
+	char *acpi_hid_str;
+	char *acpi_uid_str;
+	char *acpi_cid_str;
 };
 
 struct pci_root_info {
-        uint16_t pci_domain;
-        uint8_t pci_bus;
+	uint16_t pci_domain;
+	uint8_t pci_bus;
 };
 
 struct pci_dev_info {
-        uint16_t pci_domain;
-        uint8_t pci_bus;
-        uint8_t pci_device;
-        uint8_t pci_function;
-        char *driverlink;
+	uint16_t pci_domain;
+	uint8_t pci_bus;
+	uint8_t pci_device;
+	uint8_t pci_function;
+	char *driverlink;
 };
 
 struct scsi_info {
-        uint32_t scsi_bus;
-        uint32_t scsi_device;
-        uint32_t scsi_target;
-        uint64_t scsi_lun;
+	uint32_t scsi_bus;
+	uint32_t scsi_device;
+	uint32_t scsi_target;
+	uint64_t scsi_lun;
 };
 
 struct sas_info {
-        uint32_t scsi_bus;
-        uint32_t scsi_device;
-        uint32_t scsi_target;
-        uint64_t scsi_lun;
+	uint32_t scsi_bus;
+	uint32_t scsi_device;
+	uint32_t scsi_target;
+	uint64_t scsi_lun;
 
-        uint64_t sas_address;
+	uint64_t sas_address;
 };
 
 struct sata_info {
-        uint32_t scsi_bus;
-        uint32_t scsi_device;
-        uint32_t scsi_target;
-        uint64_t scsi_lun;
+	uint32_t scsi_bus;
+	uint32_t scsi_device;
+	uint32_t scsi_target;
+	uint64_t scsi_lun;
 
-        uint32_t ata_devno;
-        uint32_t ata_port;
-        uint32_t ata_pmp;
+	uint32_t ata_devno;
+	uint32_t ata_port;
+	uint32_t ata_pmp;
 
-        uint32_t ata_print_id;
+	uint32_t ata_print_id;
 };
 
 struct ata_info {
-        uint32_t scsi_bus;
-        uint32_t scsi_device;
-        uint32_t scsi_target;
-        uint64_t scsi_lun;
+	uint32_t scsi_bus;
+	uint32_t scsi_device;
+	uint32_t scsi_target;
+	uint64_t scsi_lun;
 
-        uint32_t scsi_host;
+	uint32_t scsi_host;
 };
 
 struct nvme_info {
-        int32_t ctrl_id;
-        int32_t ns_id;
-        int has_eui;
-        uint8_t eui[8];
+	int32_t ctrl_id;
+	int32_t ns_id;
+	int has_eui;
+	uint8_t eui[8];
 };
 
 struct nvdimm_info {
-        efi_guid_t namespace_label;
-        efi_guid_t nvdimm_label;
+	efi_guid_t namespace_label;
+	efi_guid_t nvdimm_label;
 };
 
 struct emmc_info {
@@ -98,58 +98,58 @@ struct emmc_info {
 };
 
 enum interface_type {
-        unknown,
-        isa, acpi_root, pci_root, soc_root, pci, network,
-        ata, atapi, scsi, sata, sas,
-        usb, i1394, fibre, i2o,
-        md, virtblk,
-        nvme, nd_pmem,
-        emmc,
+	unknown,
+	isa, acpi_root, pci_root, soc_root, pci, network,
+	ata, atapi, scsi, sata, sas,
+	usb, i1394, fibre, i2o,
+	md, virtblk,
+	nvme, nd_pmem,
+	emmc,
 };
 
 struct dev_probe;
 
 struct device {
-        enum interface_type interface_type;
-        uint32_t flags;
-        char *link;
-        char *device;
-        char *driver;
-
-        struct dev_probe **probes;
-        unsigned int n_probes;
-
-        union {
-                struct {
-                        struct stat stat;
-
-                        unsigned int controllernum;
-                        unsigned int disknum;
-                        int part;
-                        uint64_t major;
-                        uint32_t minor;
-                        uint32_t edd10_devicenum;
-
-                        char *disk_name;
-                        char *part_name;
-
-                        struct acpi_root_info acpi_root;
-                        struct pci_root_info pci_root;
-                        unsigned int n_pci_devs;
-                        struct pci_dev_info *pci_dev;
-
-                        union {
-                                struct scsi_info scsi_info;
-                                struct sas_info sas_info;
-                                struct sata_info sata_info;
-                                struct ata_info ata_info;
-                                struct nvme_info nvme_info;
-                                struct emmc_info emmc_info;
-                                struct nvdimm_info nvdimm_info;
-                        };
-                };
-                char *ifname;
-        };
+	enum interface_type interface_type;
+	uint32_t flags;
+	char *link;
+	char *device;
+	char *driver;
+
+	struct dev_probe **probes;
+	unsigned int n_probes;
+
+	union {
+		struct {
+			struct stat stat;
+
+			unsigned int controllernum;
+			unsigned int disknum;
+			int part;
+			uint64_t major;
+			uint32_t minor;
+			uint32_t edd10_devicenum;
+
+			char *disk_name;
+			char *part_name;
+
+			struct acpi_root_info acpi_root;
+			struct pci_root_info pci_root;
+			unsigned int n_pci_devs;
+			struct pci_dev_info *pci_dev;
+
+			union {
+				struct scsi_info scsi_info;
+				struct sas_info sas_info;
+				struct sata_info sata_info;
+				struct ata_info ata_info;
+				struct nvme_info nvme_info;
+				struct emmc_info emmc_info;
+				struct nvdimm_info nvdimm_info;
+			};
+		};
+		char *ifname;
+	};
 };
 
 extern struct device HIDDEN *device_get(int fd, int partition);
@@ -160,117 +160,117 @@ extern int HIDDEN set_part_name(struct device *dev, const char * const fmt, ...)
 extern int HIDDEN set_disk_name(struct device *dev, const char * const fmt, ...);
 extern bool HIDDEN is_pata(struct device *dev);
 extern int HIDDEN make_blockdev_path(uint8_t *buf, ssize_t size,
-                                     struct device *dev);
+				     struct device *dev);
 extern int HIDDEN parse_acpi_hid_uid(struct device *dev, const char *fmt, ...);
 extern int HIDDEN eb_nvme_ns_id(int fd, uint32_t *ns_id);
 
 int HIDDEN get_sector_size(int filedes);
 
 extern int HIDDEN find_parent_devpath(const char * const child,
-                                      char **parent);
+				      char **parent);
 
 extern ssize_t HIDDEN make_mac_path(uint8_t *buf, ssize_t size,
-                                    const char * const ifname);
-
-#define read_sysfs_file(buf, fmt, args...)                              \
-        ({                                                              \
-                uint8_t *buf_ = NULL;                                   \
-                ssize_t bufsize_ = -1;                                  \
-                int error_;                                             \
-                                                                        \
-                bufsize_ = get_file(&buf_, "/sys/" fmt, ## args);       \
-                if (bufsize_ > 0) {                                     \
-                        uint8_t *buf2_ = alloca(bufsize_);              \
-                        error_ = errno;                                 \
-                        if (buf2_)                                      \
-                                memcpy(buf2_, buf_, bufsize_);          \
-                        free(buf_);                                     \
-                        *(buf) = (__typeof__(*(buf)))buf2_;             \
-                        errno = error_;                                 \
-                } else if (buf_) {                                      \
-                        /* covscan is _sure_ we leak buf_ if bufsize_ */\
-                        /* is <= 0, which is wrong, but appease it.   */\
-                        free(buf_);                                     \
-                        buf_ = NULL;                                    \
-                }                                                       \
-                bufsize_;                                               \
-        })
-
-#define sysfs_readlink(linkbuf, fmt, args...)                           \
-        ({                                                              \
-                char *_lb = alloca(PATH_MAX+1);                         \
-                char *_pn;                                              \
-                int _rc;                                                \
-                                                                        \
-                *(linkbuf) = NULL;                                      \
-                _rc = asprintfa(&_pn, "/sys/" fmt, ## args);            \
-                if (_rc >= 0) {                                         \
-                        ssize_t _linksz;                                \
-                        _rc = _linksz = readlink(_pn, _lb, PATH_MAX);   \
-                        if (_linksz >= 0)                               \
-                                _lb[_linksz] = '\0';                    \
-                        else                                            \
-                                efi_error("readlink of %s failed", _pn);\
-                        *(linkbuf) = _lb;                               \
-                } else {                                                \
-                        efi_error("could not allocate memory");         \
-                }                                                       \
-                _rc;                                                    \
-        })
-
-#define sysfs_stat(statbuf, fmt, args...)                               \
-        ({                                                              \
-                int rc_;                                                \
-                char *pn_;                                              \
-                                                                        \
-                rc_ = asprintfa(&pn_, "/sys/" fmt, ## args);            \
-                if (rc_ >= 0) {                                         \
-                        rc_ = stat(pn_, statbuf);                       \
-                        if (rc_ < 0)                                    \
-                                efi_error("could not stat %s", pn_);    \
-                } else {                                                \
-                        efi_error("could not allocate memory");         \
-                }                                                       \
-                rc_;                                                    \
-        })
-
-#define sysfs_opendir(fmt, args...)                                     \
-        ({                                                              \
-                int rc_;                                                \
-                char *pn_;                                              \
-                DIR *dir_ = NULL;                                       \
-                                                                        \
-                rc_ = asprintfa(&pn_, "/sys/" fmt, ## args);            \
-                if (rc_ >= 0) {                                         \
-                        dir_ = opendir(pn_);                            \
-                        if (dir_ == NULL)                               \
-                                efi_error("could not open %s", pn_);    \
-                } else {                                                \
-                        efi_error("could not allocate memory");         \
-                }                                                       \
-                dir_;                                                   \
-        })
+				    const char * const ifname);
+
+#define read_sysfs_file(buf, fmt, args...)				\
+	({								\
+		uint8_t *buf_ = NULL;					\
+		ssize_t bufsize_ = -1;					\
+		int error_;						\
+									\
+		bufsize_ = get_file(&buf_, "/sys/" fmt, ## args);	\
+		if (bufsize_ > 0) {					\
+			uint8_t *buf2_ = alloca(bufsize_);		\
+			error_ = errno;					\
+			if (buf2_)					\
+				memcpy(buf2_, buf_, bufsize_);		\
+			free(buf_);					\
+			*(buf) = (__typeof__(*(buf)))buf2_;		\
+			errno = error_;					\
+		} else if (buf_) {					\
+			/* covscan is _sure_ we leak buf_ if bufsize_ */\
+			/* is <= 0, which is wrong, but appease it.   */\
+			free(buf_);					\
+			buf_ = NULL;					\
+		}							\
+		bufsize_;						\
+	})
+
+#define sysfs_readlink(linkbuf, fmt, args...)				\
+	({								\
+		char *_lb = alloca(PATH_MAX+1);				\
+		char *_pn;						\
+		int _rc;						\
+									\
+		*(linkbuf) = NULL;					\
+		_rc = asprintfa(&_pn, "/sys/" fmt, ## args);		\
+		if (_rc >= 0) {						\
+			ssize_t _linksz;				\
+			_rc = _linksz = readlink(_pn, _lb, PATH_MAX);   \
+			if (_linksz >= 0)				\
+				_lb[_linksz] = '\0';			\
+			else						\
+				efi_error("readlink of %s failed", _pn);\
+			*(linkbuf) = _lb;				\
+		} else {						\
+			efi_error("could not allocate memory");		\
+		}							\
+		_rc;							\
+	})
+
+#define sysfs_stat(statbuf, fmt, args...)				\
+	({								\
+		int rc_;						\
+		char *pn_;						\
+									\
+		rc_ = asprintfa(&pn_, "/sys/" fmt, ## args);		\
+		if (rc_ >= 0) {						\
+			rc_ = stat(pn_, statbuf);			\
+			if (rc_ < 0)					\
+				efi_error("could not stat %s", pn_);    \
+		} else {						\
+			efi_error("could not allocate memory");		\
+		}							\
+		rc_;							\
+	})
+
+#define sysfs_opendir(fmt, args...)					\
+	({								\
+		int rc_;						\
+		char *pn_;						\
+		DIR *dir_ = NULL;					\
+									\
+		rc_ = asprintfa(&pn_, "/sys/" fmt, ## args);		\
+		if (rc_ >= 0) {						\
+			dir_ = opendir(pn_);				\
+			if (dir_ == NULL)				\
+				efi_error("could not open %s", pn_);    \
+		} else {						\
+			efi_error("could not allocate memory");		\
+		}							\
+		dir_;							\
+	})
 
 #define DEV_PROVIDES_ROOT       1
-#define DEV_PROVIDES_HD         2
-#define DEV_ABBREV_ONLY         4
+#define DEV_PROVIDES_HD	 2
+#define DEV_ABBREV_ONLY	 4
 
 struct dev_probe {
-        char *name;
-        enum interface_type *iftypes;
-        uint32_t flags;
-        ssize_t (*parse)(struct device *dev,
-                         const char * const current, const char * const root);
-        ssize_t (*create)(struct device *dev,
-                          uint8_t *buf, ssize_t size, ssize_t off);
-        char *(*make_part_name)(struct device *dev);
+	char *name;
+	enum interface_type *iftypes;
+	uint32_t flags;
+	ssize_t (*parse)(struct device *dev,
+			 const char * const current, const char * const root);
+	ssize_t (*create)(struct device *dev,
+			  uint8_t *buf, ssize_t size, ssize_t off);
+	char *(*make_part_name)(struct device *dev);
 };
 
 extern ssize_t parse_scsi_link(const char *current, uint32_t *host,
-                               uint32_t *bus, uint32_t *device,
-                               uint32_t *target, uint64_t *lun,
-                               uint32_t *local_port_id, uint32_t *remote_port_id,
-                               uint32_t *remote_target_id);
+			       uint32_t *bus, uint32_t *device,
+			       uint32_t *target, uint64_t *lun,
+			       uint32_t *local_port_id, uint32_t *remote_port_id,
+			       uint32_t *remote_target_id);
 
 /* device support implementations */
 extern struct dev_probe pmem_parser;
@@ -288,3 +288,5 @@ extern struct dev_probe ata_parser;
 extern struct dev_probe emmc_parser;
 
 #endif /* _EFIBOOT_LINUX_H */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/path-helpers.h b/src/path-helpers.h
index 355f4be56af..7dec05b6297 100644
--- a/src/path-helpers.h
+++ b/src/path-helpers.h
@@ -24,25 +24,26 @@ void HIDDEN fill_spans(const char *str, const char *reject, void *spanbuf);
 unsigned int HIDDEN count_spans(const char *str, const char *reject, unsigned int *chars);
 int HIDDEN find_path_segment(const char *path, int segment, const char **pos, size_t *len);
 
-#define pathseg(path, seg)                                              \
-        ({                                                              \
-                const char *pos_ = NULL;                                \
-                char *ret_ = NULL;                                      \
-                size_t len_ = 0;                                        \
-                int rc_;                                                \
-                                                                        \
-                rc_ = find_path_segment(path, seg, &pos_, &len_);       \
-                if (rc_ >= 0) {                                         \
-                        ret_ = alloca(len_ + 1);                        \
-                        if (ret_) {                                     \
-                                memcpy(ret_, pos_, len_);               \
-                                ret_[len_] = '\0';                      \
-                        }                                               \
-                }                                                       \
-                ret_;                                                   \
-        })
+#define pathseg(path, seg)						\
+	({								\
+		const char *pos_ = NULL;				\
+		char *ret_ = NULL;					\
+		size_t len_ = 0;					\
+		int rc_;						\
+									\
+		rc_ = find_path_segment(path, seg, &pos_, &len_);       \
+		if (rc_ >= 0) {						\
+			ret_ = alloca(len_ + 1);			\
+			if (ret_) {					\
+				memcpy(ret_, pos_, len_);		\
+				ret_[len_] = '\0';			\
+			}						\
+		}							\
+		ret_;							\
+	})
 
 
 
 #endif /* !PATH_HELPER_H_ */
-// vim:fenc=utf-8:tw=75:et
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/ucs2.h b/src/ucs2.h
index fd8b056ad25..176f9ccac57 100644
--- a/src/ucs2.h
+++ b/src/ucs2.h
@@ -180,3 +180,5 @@ utf8_to_ucs2(void *ucs2void, ssize_t size, int terminate, uint8_t *utf8)
 };
 
 #endif /* _EFIVAR_UCS2_H */
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/util.h b/src/util.h
index ec1c5f1a69a..712abea2d42 100644
--- a/src/util.h
+++ b/src/util.h
@@ -75,322 +75,322 @@
 #endif
 #endif
 #ifndef int_add
-#define int_add(a, b, c) ({                                             \
-                const int _limit = INT_MAX;                             \
-                int _ret;                                               \
-                _ret = _limit - ((unsigned long long)a) >               \
-                          ((unsigned long long)b);                      \
-                if (!_ret)                                              \
-                        *(c) = ((a) + (b));                             \
-                _ret;                                                   \
-        })
+#define int_add(a, b, c) ({					\
+		const int _limit = INT_MAX;			\
+		int _ret;					\
+		_ret = _limit - ((unsigned long long)a) >	\
+			  ((unsigned long long)b);		\
+		if (!_ret)					\
+			*(c) = ((a) + (b));			\
+		_ret;						\
+	})
 #endif
 #ifndef long_add
-#define long_add(a, b, c) ({                                            \
-                const long _limit = LONG_MAX;                           \
-                int _ret;                                               \
-                _ret = _limit - ((unsigned long long)a) >               \
-                           ((unsigned long long)b);                     \
-                if (!_ret)                                              \
-                        *(c) = ((a) + (b));                             \
-                _ret;                                                   \
-        })
+#define long_add(a, b, c) ({					\
+		const long _limit = LONG_MAX;			\
+		int _ret;					\
+		_ret = _limit - ((unsigned long long)a) >	\
+			   ((unsigned long long)b);		\
+		if (!_ret)					\
+			*(c) = ((a) + (b));			\
+		_ret;						\
+	})
 #endif
 #ifndef long_mult
-#define long_mult(a, b, c) ({                                           \
-                const long _limit = LONG_MAX;                           \
-                int _ret = 1;                                           \
-                if ((a) == 0 || (b) == 0)                               \
-                        _ret = 0;                                       \
-                else                                                    \
-                        _ret = _limit / (a) < (b);                      \
-                if (!_ret)                                              \
-                        *(c) = ((a) * (b));                             \
-                _ret;                                                   \
-        })
+#define long_mult(a, b, c) ({					\
+		const long _limit = LONG_MAX;			\
+		int _ret = 1;					\
+		if ((a) == 0 || (b) == 0)			\
+			_ret = 0;				\
+		else						\
+			_ret = _limit / (a) < (b);		\
+		if (!_ret)					\
+			*(c) = ((a) * (b));			\
+		_ret;						\
+	})
 #endif
 #ifndef ulong_add
-#define ulong_add(a, b, c) ({                                           \
-                const unsigned long _limit = ULONG_MAX;                 \
-                int _ret;                                               \
-                _ret = _limit - ((unsigned long long)a) >               \
-                            ((unsigned long long)b);                    \
-                if (!_ret)                                              \
-                        *(c) = ((a) + (b));                             \
-                _ret;                                                   \
-        })
+#define ulong_add(a, b, c) ({					\
+		const unsigned long _limit = ULONG_MAX;		\
+		int _ret;					\
+		_ret = _limit - ((unsigned long long)a) >	\
+			    ((unsigned long long)b);		\
+		if (!_ret)					\
+			*(c) = ((a) + (b));			\
+		_ret;						\
+	})
 #endif
 #ifndef ulong_mult
-#define ulong_mult(a, b, c) ({                                          \
-                const unsigned long _limit = ULONG_MAX;                 \
-                int _ret = 1;                                           \
-                if ((a) == 0 || (b) == 0)                               \
-                        _ret = 0;                                       \
-                else                                                    \
-                        _ret = _limit / (a) < (b);                      \
-                if (!_ret)                                              \
-                        *(c) = ((a) * (b));                             \
-                _ret;                                                   \
-        })
+#define ulong_mult(a, b, c) ({					\
+		const unsigned long _limit = ULONG_MAX;		\
+		int _ret = 1;					\
+		if ((a) == 0 || (b) == 0)			\
+			_ret = 0;				\
+		else						\
+			_ret = _limit / (a) < (b);		\
+		if (!_ret)					\
+			*(c) = ((a) * (b));			\
+		_ret;						\
+	})
 #endif
 
 #if defined(__GNUC__) && defined(__GNUC_MINOR__)
 #if __GNUC__ >= 5 && __GNUC_MINOR__ >= 1
-#define add(a, b, c) _Generic((c),                                      \
-                              int *: int_add(a,b,c),                    \
-                              long *: long_add(a,b,c),                  \
-                              unsigned long *: ulong_add(a,b,c))
-#define mult(a, b, c) _Generic((c),                                     \
-                              long *: long_mult(a,b,c),                 \
-                              unsigned long *: ulong_mult(a,b,c))
+#define add(a, b, c) _Generic((c),				\
+			      int *: int_add(a,b,c),		\
+			      long *: long_add(a,b,c),		\
+			      unsigned long *: ulong_add(a,b,c))
+#define mult(a, b, c) _Generic((c),				\
+			      long *: long_mult(a,b,c),		\
+			      unsigned long *: ulong_mult(a,b,c))
 #endif
 #endif
 
 #ifndef add
-#define add(a, b, c) ({                                                 \
-                (*(c)) = ((a) + (b));                                   \
-                })
+#define add(a, b, c) ({						\
+		(*(c)) = ((a) + (b));				\
+		})
 #endif
 #ifndef mult
-#define mult(a, b, c) ({                                                \
-                (*(c)) = ((a) * (b));                                   \
-                })
+#define mult(a, b, c) ({					\
+		(*(c)) = ((a) * (b));				\
+		})
 #endif
 
 static inline int UNUSED
 read_file(int fd, uint8_t **result, size_t *bufsize)
 {
-        uint8_t *p;
-        size_t size = 4096;
-        size_t filesize = 0;
-        ssize_t s = 0;
-        uint8_t *buf, *newbuf;
+	uint8_t *p;
+	size_t size = 4096;
+	size_t filesize = 0;
+	ssize_t s = 0;
+	uint8_t *buf, *newbuf;
 
-        if (!(newbuf = calloc(size, sizeof (uint8_t)))) {
-                efi_error("could not allocate memory");
-                *result = buf = NULL;
-                *bufsize = 0;
-                return -1;
-        }
-        buf = newbuf;
+	if (!(newbuf = calloc(size, sizeof (uint8_t)))) {
+		efi_error("could not allocate memory");
+		*result = buf = NULL;
+		*bufsize = 0;
+		return -1;
+	}
+	buf = newbuf;
 
-        do {
-                p = buf + filesize;
-                /* size - filesize shouldn't exceed SSIZE_MAX because we're
-                 * only allocating 4096 bytes at a time and we're checking that
-                 * before doing so. */
-                s = read(fd, p, size - filesize);
-                if (s < 0 && errno == EAGAIN) {
-                        /*
-                         * if we got EAGAIN, there's a good chance we've hit
-                         * the kernel rate limiter.  Doing more reads is just
-                         * going to make it worse, so instead, give it a rest.
-                         */
-                        sched_yield();
-                        continue;
-                } else if (s < 0) {
-                        int saved_errno = errno;
-                        free(buf);
-                        *result = buf = NULL;
-                        *bufsize = 0;
-                        errno = saved_errno;
-                        efi_error("could not read from file");
-                        return -1;
-                }
-                filesize += s;
-                /* only exit for empty reads */
-                if (s == 0)
-                        break;
-                if (filesize >= size) {
-                        /* See if we're going to overrun and return an error
-                         * instead. */
-                        if (size > (size_t)-1 - 4096) {
-                                free(buf);
-                                *result = buf = NULL;
-                                *bufsize = 0;
-                                errno = ENOMEM;
-                                efi_error("could not read from file");
-                                return -1;
-                        }
-                        newbuf = realloc(buf, size + 4096);
-                        if (newbuf == NULL) {
-                                int saved_errno = errno;
-                                free(buf);
-                                *result = buf = NULL;
-                                *bufsize = 0;
-                                errno = saved_errno;
-                                efi_error("could not allocate memory");
-                                return -1;
-                        }
-                        buf = newbuf;
-                        memset(buf + size, '\0', 4096);
-                        size += 4096;
-                }
-        } while (1);
+	do {
+		p = buf + filesize;
+		/* size - filesize shouldn't exceed SSIZE_MAX because we're
+		 * only allocating 4096 bytes at a time and we're checking that
+		 * before doing so. */
+		s = read(fd, p, size - filesize);
+		if (s < 0 && errno == EAGAIN) {
+			/*
+			 * if we got EAGAIN, there's a good chance we've hit
+			 * the kernel rate limiter.  Doing more reads is just
+			 * going to make it worse, so instead, give it a rest.
+			 */
+			sched_yield();
+			continue;
+		} else if (s < 0) {
+			int saved_errno = errno;
+			free(buf);
+			*result = buf = NULL;
+			*bufsize = 0;
+			errno = saved_errno;
+			efi_error("could not read from file");
+			return -1;
+		}
+		filesize += s;
+		/* only exit for empty reads */
+		if (s == 0)
+			break;
+		if (filesize >= size) {
+			/* See if we're going to overrun and return an error
+			 * instead. */
+			if (size > (size_t)-1 - 4096) {
+				free(buf);
+				*result = buf = NULL;
+				*bufsize = 0;
+				errno = ENOMEM;
+				efi_error("could not read from file");
+				return -1;
+			}
+			newbuf = realloc(buf, size + 4096);
+			if (newbuf == NULL) {
+				int saved_errno = errno;
+				free(buf);
+				*result = buf = NULL;
+				*bufsize = 0;
+				errno = saved_errno;
+				efi_error("could not allocate memory");
+				return -1;
+			}
+			buf = newbuf;
+			memset(buf + size, '\0', 4096);
+			size += 4096;
+		}
+	} while (1);
 
-        newbuf = realloc(buf, filesize+1);
-        if (!newbuf) {
-                free(buf);
-                *result = buf = NULL;
-                efi_error("could not allocate memory");
-                return -1;
-        }
-        newbuf[filesize] = '\0';
-        *result = newbuf;
-        *bufsize = filesize+1;
-        return 0;
+	newbuf = realloc(buf, filesize+1);
+	if (!newbuf) {
+		free(buf);
+		*result = buf = NULL;
+		efi_error("could not allocate memory");
+		return -1;
+	}
+	newbuf[filesize] = '\0';
+	*result = newbuf;
+	*bufsize = filesize+1;
+	return 0;
 }
 
 static inline uint64_t UNUSED
 lcm(uint64_t x, uint64_t y)
 {
-        uint64_t m = x, n = y, o;
-        while ((o = m % n)) {
-                m = n;
-                n = o;
-        }
-        return (x / n) * y;
+	uint64_t m = x, n = y, o;
+	while ((o = m % n)) {
+		m = n;
+		n = o;
+	}
+	return (x / n) * y;
 }
 
 #ifndef strdupa
-#define strdupa(s)                                                      \
-       (__extension__ ({                                                \
-                const char *__in = (s);                                 \
-                size_t __len = strlen (__in);                           \
-                char *__out = (char *) alloca (__len + 1);              \
-                strcpy(__out, __in);                                    \
-                __out;                                                  \
-        }))
+#define strdupa(s)						      \
+       (__extension__ ({						\
+		const char *__in = (s);				 \
+		size_t __len = strlen (__in);			   \
+		char *__out = (char *) alloca (__len + 1);	      \
+		strcpy(__out, __in);				    \
+		__out;						  \
+	}))
 #endif
 
 #ifndef strndupa
-#define strndupa(s, l)                                                  \
-       (__extension__ ({                                                \
-                const char *__in = (s);                                 \
-                size_t __len = strnlen (__in, (l));                     \
-                char *__out = (char *) alloca (__len + 1);              \
-                strncpy(__out, __in, __len);                            \
-                __out[__len] = '\0';                                    \
-                __out;                                                  \
-        }))
+#define strndupa(s, l)						  \
+       (__extension__ ({						\
+		const char *__in = (s);				 \
+		size_t __len = strnlen (__in, (l));		     \
+		char *__out = (char *) alloca (__len + 1);	      \
+		strncpy(__out, __in, __len);			    \
+		__out[__len] = '\0';				    \
+		__out;						  \
+	}))
 #endif
 
-#define asprintfa(str, fmt, args...)                                    \
-        ({                                                              \
-                char *_tmp = NULL;                                      \
-                int _rc;                                                \
-                *(str) = NULL;                                          \
-                _rc = asprintf((str), (fmt), ## args);                  \
-                if (_rc > 0) {                                          \
-                        _tmp = strdupa(*(str));                         \
-                        if (!_tmp) {                                    \
-                                _rc = -1;                               \
-                        } else {                                        \
-                                free(*(str));                           \
-                                *(str) = _tmp;                          \
-                        }                                               \
-                } else {                                                \
-                        _rc = -1;                                       \
-                }                                                       \
-                _rc;                                                    \
-        })
+#define asprintfa(str, fmt, args...)				    \
+	({							      \
+		char *_tmp = NULL;				      \
+		int _rc;						\
+		*(str) = NULL;					  \
+		_rc = asprintf((str), (fmt), ## args);		  \
+		if (_rc > 0) {					  \
+			_tmp = strdupa(*(str));			 \
+			if (!_tmp) {				    \
+				_rc = -1;			       \
+			} else {					\
+				free(*(str));			   \
+				*(str) = _tmp;			  \
+			}					       \
+		} else {						\
+			_rc = -1;				       \
+		}						       \
+		_rc;						    \
+	})
 
-#define vasprintfa(str, fmt, ap)                                        \
-        ({                                                              \
-                char *_tmp = NULL;                                      \
-                int _rc;                                                \
-                *(str) = NULL;                                          \
-                _rc = vasprintf((str), (fmt), (ap));                    \
-                if (_rc > 0) {                                          \
-                        _tmp = strdupa(*(str));                         \
-                        if (!_tmp) {                                    \
-                                _rc = -1;                               \
-                        } else {                                        \
-                                free(*(str));                           \
-                                *(str) = _tmp;                          \
-                        }                                               \
-                } else {                                                \
-                        _rc = -1;                                       \
-                }                                                       \
-                _rc;                                                    \
-        })
+#define vasprintfa(str, fmt, ap)					\
+	({							      \
+		char *_tmp = NULL;				      \
+		int _rc;						\
+		*(str) = NULL;					  \
+		_rc = vasprintf((str), (fmt), (ap));		    \
+		if (_rc > 0) {					  \
+			_tmp = strdupa(*(str));			 \
+			if (!_tmp) {				    \
+				_rc = -1;			       \
+			} else {					\
+				free(*(str));			   \
+				*(str) = _tmp;			  \
+			}					       \
+		} else {						\
+			_rc = -1;				       \
+		}						       \
+		_rc;						    \
+	})
 
 static inline ssize_t
 get_file(uint8_t **result, const char * const fmt, ...)
 {
-        char *path;
-        uint8_t *buf = NULL;
-        size_t bufsize = 0;
-        ssize_t rc;
-        va_list ap;
-        int error;
-        int fd;
+	char *path;
+	uint8_t *buf = NULL;
+	size_t bufsize = 0;
+	ssize_t rc;
+	va_list ap;
+	int error;
+	int fd;
 
-        if (result == NULL) {
-                efi_error("invalid parameter 'result'");
-                return -1;
-        }
+	if (result == NULL) {
+		efi_error("invalid parameter 'result'");
+		return -1;
+	}
 
-        va_start(ap, fmt);
-        rc = vasprintfa(&path, fmt, ap);
-        va_end(ap);
-        if (rc < 0) {
-                efi_error("could not allocate memory");
-                return -1;
-        }
+	va_start(ap, fmt);
+	rc = vasprintfa(&path, fmt, ap);
+	va_end(ap);
+	if (rc < 0) {
+		efi_error("could not allocate memory");
+		return -1;
+	}
 
-        fd = open(path, O_RDONLY);
-        if (fd < 0) {
-                efi_error("could not open file \"%s\" for reading",
-                          path);
-                return -1;
-        }
+	fd = open(path, O_RDONLY);
+	if (fd < 0) {
+		efi_error("could not open file \"%s\" for reading",
+			  path);
+		return -1;
+	}
 
-        rc = read_file(fd, &buf, &bufsize);
-        error = errno;
-        close(fd);
-        errno = error;
+	rc = read_file(fd, &buf, &bufsize);
+	error = errno;
+	close(fd);
+	errno = error;
 
-        if (rc < 0 || bufsize < 1) {
-                /*
-                 * I don't think this can happen, but I can't convince
-                 * cov-scan
-                 */
-                if (buf)
-                        free(buf);
-                *result = NULL;
-                efi_error("could not read file \"%s\"", path);
-                return -1;
-        }
+	if (rc < 0 || bufsize < 1) {
+		/*
+		 * I don't think this can happen, but I can't convince
+		 * cov-scan
+		 */
+		if (buf)
+			free(buf);
+		*result = NULL;
+		efi_error("could not read file \"%s\"", path);
+		return -1;
+	}
 
-        *result = buf;
-        return bufsize;
+	*result = buf;
+	return bufsize;
 }
 
 static inline void UNUSED
 swizzle_guid_to_uuid(efi_guid_t *guid)
 {
-        uint32_t *u32;
-        uint16_t *u16;
+	uint32_t *u32;
+	uint16_t *u16;
 
-        u32 = (uint32_t *)guid;
-        u32[0] = __builtin_bswap32(u32[0]);
-        u16 = (uint16_t *)&u32[1];
-        u16[0] = __builtin_bswap16(u16[0]);
-        u16[1] = __builtin_bswap16(u16[1]);
+	u32 = (uint32_t *)guid;
+	u32[0] = __builtin_bswap32(u32[0]);
+	u16 = (uint16_t *)&u32[1];
+	u16[0] = __builtin_bswap16(u16[0]);
+	u16[1] = __builtin_bswap16(u16[1]);
 }
 
-#define log_(file, line, func, level, fmt, args...)                     \
-        ({                                                              \
-                efi_set_loglevel(level);                                \
-                FILE *logfile_ = efi_get_logfile();                     \
-                int len_ = strlen(fmt);                                 \
-                fprintf(logfile_, "%s:%d %s(): ",                       \
-                        file, line, func);                              \
-                fprintf(logfile_, fmt, ## args);                        \
-                if (!len_ || fmt[len_ - 1] != '\n')                     \
-                        fprintf(logfile_, "\n");                        \
-        })
+#define log_(file, line, func, level, fmt, args...)			\
+	({								\
+		efi_set_loglevel(level);				\
+		FILE *logfile_ = efi_get_logfile();			\
+		int len_ = strlen(fmt);					\
+		fprintf(logfile_, "%s:%d %s(): ",			\
+			file, line, func);				\
+		fprintf(logfile_, fmt, ## args);			\
+		if (!len_ || fmt[len_ - 1] != '\n')			\
+			fprintf(logfile_, "\n");			\
+	})
 
 #define LOG_VERBOSE 0
 #define LOG_DEBUG 1
@@ -399,14 +399,16 @@ swizzle_guid_to_uuid(efi_guid_t *guid)
 #endif
 #define log(level, fmt, args...) log_(__FILE__, __LINE__, __func__, level, fmt, ## args)
 #define debug(fmt, args...) log(LOG_DEBUG, fmt, ## args)
-#define log_hex_(file, line, func, level, buf, size)                    \
-        ({                                                              \
-                efi_set_loglevel(level);                                \
-                fhexdumpf(efi_get_logfile(), "%s:%d %s(): ",            \
-                          (uint8_t *)buf, size,                         \
-                          file, line, func);                            \
-        })
+#define log_hex_(file, line, func, level, buf, size)			\
+	({								\
+		efi_set_loglevel(level);				\
+		fhexdumpf(efi_get_logfile(), "%s:%d %s(): ",		\
+			  (uint8_t *)buf, size,				\
+			  file, line, func);				\
+	})
 #define log_hex(level, buf, size) log_hex_(__FILE__, __LINE__, __func__, level, buf, size)
 #define debug_hex(buf, size) log_hex(LOG_DEBUG, buf, size)
 
 #endif /* EFIVAR_UTIL_H */
+
+// vim:fenc=utf-8:tw=75:noet
-- 
2.26.2

